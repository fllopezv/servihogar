CREATE TABLE distribuidora.pais(
	COD_PAIS VARCHAR(10),
	NOMBRE_PAIS VARCHAR(20) NOT NULL,
	CONSTRAINT PK_COD_PAIS PRIMARY KEY(COD_PAIS),
	CONSTRAINT UC_NOMBRE_PAIS UNIQUE(NOMBRE_PAIS)
);
CREATE TABLE distribuidora.DEPARTAMENTO(
	COD_DEPARTAMENTO VARCHAR(10),
	NOMBRE_DEPARTAMENTO VARCHAR(30) NOT NULL,
	COD_PAIS VARCHAR(10),
	CONSTRAINT FK_COD_PAIS FOREIGN KEY (COD_PAIS) REFERENCES distribuidora.PAIS(COD_PAIS),
	CONSTRAINT PK_COD_DEPARTAMENTO PRIMARY KEY(COD_PAIS, COD_DEPARTAMENTO),
	CONSTRAINT UC_NOMBRE_DEPARTAMENTO UNIQUE(NOMBRE_DEPARTAMENTO)
);
CREATE TABLE distribuidora.CIUDAD(
	COD_CIUDAD VARCHAR(10),
	NOMBRE_CIUDAD VARCHAR(30) NOT NULL,
	COD_PAIS VARCHAR(10),
	COD_DEPARTAMENTO VARCHAR(10),
	CONSTRAINT FK_COD_PAIS_DEPARTAMENTO FOREIGN KEY(COD_PAIS, COD_DEPARTAMENTO) REFERENCES distribuidora.DEPARTAMENTO(COD_PAIS, COD_DEPARTAMENTO),
	CONSTRAINT PK_COD_CIUDAD PRIMARY KEY(COD_PAIS, COD_DEPARTAMENTO, COD_CIUDAD)
);
CREATE TABLE distribuidora.proveedor (
	NIT VARCHAR(20),
	NOMBRE VARCHAR (80),
	DIRECCION VARCHAR(40),
	CELULAR VARCHAR(15),
	COD_PAIS VARCHAR(10),
	COD_DEPARTAMENTO VARCHAR(10),
	COD_CIUDAD VARCHAR(10),
	CONSTRAINT NN_NOMBRE CHECK (NOMBRE IS NOT NULL),
	CONSTRAINT NN_CELULAR CHECK (CELULAR IS NOT NULL),
	CONSTRAINT NN_DIRECCION CHECK (DIRECCION IS NOT NULL),
	CONSTRAINT FK_CIUDAD_PROVEEDOR FOREIGN KEY (COD_PAIS, COD_DEPARTAMENTO, COD_CIUDAD) REFERENCES distribuidora.CIUDAD(COD_PAIS, COD_DEPARTAMENTO, COD_CIUDAD),
	CONSTRAINT PK_PROVEEDOR PRIMARY KEY(NIT)
);
CREATE TABLE distribuidora.CLIENTE (
	CLIE_DOCUMENTO VARCHAR(15),
	CLIE_NOMBRE1 VARCHAR(15),
	CLIE_NOMBRE2 VARCHAR(15),
	CLIE_APELLIDO1 VARCHAR(15),
	CLIE_APELLIDO2 VARCHAR(15),
	CLIE_DIRECCION VARCHAR(50),
	CLIE_SEXO CHAR(1),
	CLIE_CELULAR VARCHAR(20),
	CLIE_EMAIL VARCHAR(30),
	COD_PAIS VARCHAR(10),
	COD_DEPARTAMENTO VARCHAR(10),
	COD_CIUDAD VARCHAR(10),
	CONSTRAINT CK_SEXO CHECK (CLIE_SEXO IN ('M', 'F')),
	CONSTRAINT NN_NOMBRE1 CHECK (CLIE_NOMBRE1 IS NOT NULL),
	CONSTRAINT NN_APELLIDO1 CHECK (CLIE_APELLIDO1 IS NOT NULL),
	CONSTRAINT NN_CELULAR CHECK (CLIE_CELULAR IS NOT NULL),
	CONSTRAINT NN_DIRECCION CHECK (CLIE_DIRECCION IS NOT NULL),
	CONSTRAINT FK_CIUDAD_CLIENTE FOREIGN KEY (COD_PAIS, COD_DEPARTAMENTO, COD_CIUDAD) REFERENCES distribuidora.CIUDAD(COD_PAIS, COD_DEPARTAMENTO, COD_CIUDAD),
	CONSTRAINT PK_CLIENTE PRIMARY KEY (CLIE_DOCUMENTO)
);
CREATE TABLE distribuidora.tipo_empleado (
	tipo_id VARCHAR (2),
	tipo_nombre VARCHAR (20),
	CONSTRAINT NN_TIPO_NOMBRE CHECK (TIPO_NOMBRE IS NOT NULL),
	CONSTRAINT PK_TIPO_EMPLEADO PRIMARY KEY (tipo_id)
);

INSERT INTO distribuidora.tipo_empleado (tipo_id,tipo_nombre)
								VALUES 	('A0','ADMINISTRADOR'),
										('A1','GERENTE');

CREATE TABLE distribuidora.empleado (
	EMP_DOCUMENTO VARCHAR(15),
	EMP_CODIGO VARCHAR (3),
	EMP_NOMBRE1 VARCHAR(15),
	EMP_NOMBRE2 VARCHAR(15),
	EMP_APELLIDO1 VARCHAR(15),
	EMP_APELLIDO2 VARCHAR(15),
	EMP_DIRECCION VARCHAR(50),
	EMP_SEXO CHAR(1),
	EMP_CELULAR VARCHAR(20),
	EMP_EMAIL VARCHAR(30),
	TIPO_ID VARCHAR (2),
	CONSTRAINT CK_SEXO CHECK (EMP_SEXO IN ('M', 'F')),
	CONSTRAINT NN_NOMBRE1 CHECK (EMP_NOMBRE1 IS NOT NULL),
	CONSTRAINT NN_APELLIDO1 CHECK (EMP_APELLIDO1 IS NOT NULL),
	CONSTRAINT NN_CELULAR CHECK (EMP_CELULAR IS NOT NULL),
	CONSTRAINT NN_DIRECCION CHECK (EMP_DIRECCION IS NOT NULL),
	CONSTRAINT PK_EMPLEADO PRIMARY KEY (EMP_DOCUMENTO),
	CONSTRAINT FK_TIPO_EMPLEADO_EMPLEADO FOREIGN KEY (tipo_id) REFERENCES distribuidora.tipo_empleado (tipo_id)
);

INSERT INTO distribuidora.empleado (EMP_DOCUMENTO,EMP_CODIGO,EMP_NOMBRE1,EMP_NOMBRE2,EMP_APELLIDO1,EMP_APELLIDO2,EMP_DIRECCION,EMP_SEXO,EMP_CELULAR,EMP_EMAIL,TIPO_ID)
							VALUES ('1003125673','A23','andres','felipe','Guagliabgnoni','Picon','cra 45 - 32','M','3214563472','felipe@gmail.com','A0');

CREATE TABLE distribuidora.factura_salida (
	CONSECUTIVO_SALIDA SERIAL,
	FECHA DATE,
	CLIE_DOCUMENTO VARCHAR(15),
	EMP_DOCUMENTO VARCHAR(15),
	DESCUENTO DECIMAL,
	TOTAL DECIMAL,
	CONSTRAINT NN_FECHA CHECK (FECHA IS NOT NULL),
	CONSTRAINT FK_CLIENTE_FACTURA_SALIDA FOREIGN KEY (CLIE_DOCUMENTO) REFERENCES distribuidora.cliente (CLIE_DOCUMENTO),
	CONSTRAINT FK_EMPLEADO_FACTURA_SALIDA FOREIGN KEY (EMP_DOCUMENTO) REFERENCES distribuidora.empleado (EMP_DOCUMENTO),
	CONSTRAINT PK_FACTURA_SALIDA PRIMARY KEY (CONSECUTIVO_SALIDA)
);
CREATE TABLE distribuidora.producto (
	COD_PRODUCTO VARCHAR(5),
	PROD_NOMBRE VARCHAR(40),
	PROD_DESCRIPCION VARCHAR (100),
	VALOR DECIMAL,
	STOCK INTEGER,
	ENTRADA INTEGER,
	CONSTRAINT PK_PRODUCTO PRIMARY KEY (COD_PRODUCTO),
	CONSTRAINT NN_NOMBRE CHECK (PROD_NOMBRE IS NOT NULL),
	CONSTRAINT NN_DESCRIPCION CHECK (PROD_DESCRIPCION IS NOT NULL),
	CONSTRAINT CK_VALOR CHECK (VALOR > 0)
);
CREATE TABLE distribuidora.detalle_salida (
	CONSECUTIVO_SALIDA INTEGER,
	ORDINAL VARCHAR (2),
	COD_PRODUCTO VARCHAR(5),
	CANTIDAD_VENTA INTEGER,
	PRECIO_VENTA DECIMAL,
	SUBTOTAL DECIMAL,
	DESCUENTO DECIMAL,
	VLR_DESCUENTO DECIMAL,
	CONSTRAINT NN_ORDINAL CHECK (ORDINAL IS NOT NULL),
	CONSTRAINT CK_CANTIDAD CHECK (CANTIDAD_VENTA > 0),
	CONSTRAINT FK_PRODUCTO_DETALLE_SALIDA FOREIGN KEY (COD_PRODUCTO) REFERENCES distribuidora.producto (COD_PRODUCTO),
	CONSTRAINT FK_FACTURA_SALIDA_DETALLE_SALIDA FOREIGN KEY (CONSECUTIVO_SALIDA) REFERENCES distribuidora.factura_salida (CONSECUTIVO_SALIDA),
	CONSTRAINT PK_DETALLE_SALIDA PRIMARY KEY (CONSECUTIVO_SALIDA, ORDINAL)
);
CREATE TABLE distribuidora.factura_entrada (
	CONSECUTIVO_ENTRADA SERIAL,
	FECHA DATE,
	EMP_DOCUMENTO VARCHAR(15),
	DESCUENTO DECIMAL,
	TOTAL DECIMAL,
	CONSTRAINT NN_FECHA CHECK (FECHA IS NOT NULL),
	CONSTRAINT FK_EMPLEADO_FACTURA_ENTRADA FOREIGN KEY (EMP_DOCUMENTO) REFERENCES distribuidora.empleado (EMP_DOCUMENTO),
	CONSTRAINT PK_FACTURA_ENTRADA PRIMARY KEY (CONSECUTIVO_ENTRADA)
);
CREATE TABLE distribuidora.detalle_entrada (
	CONSECUTIVO_ENTRADA INTEGER,
	ORDINAL_ENTRADA VARCHAR (2),
	COD_PRODUCTO VARCHAR(5),
	CANTIDAD_VENTA INTEGER,
	PRECIO_VENTA DECIMAL,
	SUBTOTAL DECIMAL,
	DESCUENTO DECIMAL,
	VLR_DESCUENTO DECIMAL,
	CONSTRAINT NN_ORDINAL CHECK (ORDINAL_ENTRADA IS NOT NULL),
	CONSTRAINT CK_CANTIDAD CHECK (CANTIDAD_VENTA > 0),
	CONSTRAINT FK_PRODUCTO_DETALLE_ENTRADA FOREIGN KEY (COD_PRODUCTO) REFERENCES distribuidora.producto (COD_PRODUCTO),
	CONSTRAINT FK_FACTURA_ENTRADA_DETALLE_ENTRADA FOREIGN KEY (CONSECUTIVO_ENTRADA) REFERENCES distribuidora.factura_entrada (CONSECUTIVO_ENTRADA),
	CONSTRAINT PK_DETALLE_ENTRADA PRIMARY KEY (CONSECUTIVO_ENTRADA, ORDINAL_ENTRADA)
);
CREATE FUNCTION distribuidora.subtotal() RETURNS TRIGGER AS $llenar_subtotal$
DECLARE p numeric;
d numeric;
su numeric;
vd numeric;
BEGIN -- Chequear cantidad null
IF NEW.cantidad_venta IS NULL THEN RAISE EXCEPTION '% Cantidad no puede ser nulo',
NEW.cod_producto;
END IF;
SELECT valor into p
FROM distribuidora.producto
WHERE cod_producto = NEW.cod_producto;
d := NEW.descuento / 100;
su := NEW.cantidad_venta * p;
vd := round((su * d), 2);
NEW.precio_venta := p;
NEW.subtotal := (su - vd);
NEW.vlr_descuento := vd;
RETURN NEW;
END $llenar_subtotal$ LANGUAGE plpgsql;
CREATE TRIGGER llenar_subtotal BEFORE
INSERT
	OR
UPDATE ON distribuidora.detalle_salida FOR EACH ROW EXECUTE PROCEDURE distribuidora.subtotal();
CREATE FUNCTION distribuidora.total() RETURNS trigger AS $llenar_total$
declare sb numeric;
de numeric;
BEGIN
select sum(subtotal),
	sum(vlr_descuento) into sb,
	de
from distribuidora.detalle_salida
where consecutivo_salida = NEW.consecutivo_salida;
update distribuidora.factura_salida
set total = sb,
	descuento = de
where consecutivo_salida = NEW.consecutivo_salida;
RETURN NEW;
END;
$llenar_total$ LANGUAGE plpgsql;
CREATE TRIGGER llenar_total
AFTER
INSERT
	OR
UPDATE ON distribuidora.detalle_salida FOR EACH ROW EXECUTE PROCEDURE distribuidora.total();
CREATE TABLE distribuidora.audi_proveedor (
	consecutivo_audi_proveedor SERIAL,
	NIT VARCHAR(20),
	NOMBRE VARCHAR (80),
	DIRECCION VARCHAR(40),
	CELULAR VARCHAR(15),
	COD_PAIS VARCHAR(10),
	COD_DEPARTAMENTO VARCHAR(10),
	COD_CIUDAD VARCHAR(10),
	CONSTRAINT PK_AUDI_PROVEEDOR PRIMARY KEY(consecutivo_audi_proveedor)
);
CREATE FUNCTION distribuidora.audi_proveedor_func() RETURNS trigger AS $trg_grabar_audi_proveedor$
declare BEGIN IF (TG_OP = 'UPDATE') THEN
INSERT INTO distribuidora.audi_proveedor (
		consecutivo_audi_proveedor,
		NIT,
		NOMBRE,
		DIRECCION,
		CELULAR,
		COD_PAIS,
		COD_DEPARTAMENTO,
		COD_CIUDAD
	)
VALUES (
		default,
		OLD.NIT,
		OLD.NOMBRE,
		OLD.DIRECCION,
		OLD.CELULAR,
		OLD.COD_PAIS,
		OLD.COD_DEPARTAMENTO,
		OLD.COD_CIUDAD
	);
RETURN NEW;
ELSEIF (TG_OP = 'DELETE') THEN
INSERT INTO distribuidora.audi_proveedor (
		consecutivo_audi_proveedor,
		NIT,
		NOMBRE,
		DIRECCION,
		CELULAR
	)
VALUES (
		default,
		OLD.NIT,
		OLD.NOMBRE,
		OLD.DIRECCION,
		OLD.CELULAR,
		OLD.COD_PAIS,
		OLD.COD_DEPARTAMENTO,
		OLD.COD_CIUDAD
	);
RETURN OLD;
END IF;
END;
$trg_grabar_audi_proveedor$ LANGUAGE plpgsql;
CREATE TRIGGER trg_grabar_audi_proveedor BEFORE
UPDATE
	OR DELETE ON distribuidora.proveedor FOR EACH ROW EXECUTE PROCEDURE distribuidora.audi_proveedor_func();
CREATE TABLE distribuidora.audi_producto (
	consecutivo_audi_producto SERIAL,
	COD_PRODUCTO VARCHAR(5),
	PROD_NOMBRE VARCHAR(40),
	PROD_DESCRIPCION VARCHAR (100),
	VALOR DECIMAL,
	STOCK INTEGER,
	ENTRADA INTEGER,
	CONSTRAINT PK_AUDI_PRODUCTO PRIMARY KEY (consecutivo_audi_producto)
);
CREATE FUNCTION distribuidora.audi_producto_func() RETURNS trigger AS $trg_grabar_audi_producto$
declare BEGIN IF (TG_OP = 'UPDATE') THEN
INSERT INTO distribuidora.audi_producto (
		consecutivo_audi_producto,
		COD_PRODUCTO,
		PROD_NOMBRE,
		PROD_DESCRIPCION,
		VALOR,
		STOCK,
		ENTRADA
	)
VALUES (
		default,
		OLD.COD_PRODUCTO,
		OLD.PROD_NOMBRE,
		OLD.PROD_DESCRIPCION,
		OLD.VALOR,
		OLD.STOCK,
		OLD.ENTRADA
	);
RETURN NEW;
ELSEIF (TG_OP = 'DELETE') THEN
INSERT INTO distribuidora.audi_producto (
		consecutivo_audi_producto,
		COD_PRODUCTO,
		PROD_NOMBRE,
		PROD_DESCRIPCION,
		VALOR,
		STOCK,
		ENTRADA
	)
VALUES (
		default,
		OLD.COD_PRODUCTO,
		OLD.PROD_NOMBRE,
		OLD.PROD_DESCRIPCION,
		OLD.VALOR,
		OLD.STOCK,
		OLD.ENTRADA
	);
RETURN OLD;
END IF;
END;
$trg_grabar_audi_producto$ LANGUAGE plpgsql;
CREATE TRIGGER trg_grabar_audi_producto BEFORE
UPDATE
	OR DELETE ON distribuidora.producto FOR EACH ROW EXECUTE PROCEDURE distribuidora.audi_producto_func();
CREATE FUNCTION distribuidora.stock() RETURNS TRIGGER AS $actualizar_stock$
DECLARE p numeric;
BEGIN
SELECT stock into p
FROM distribuidora.producto
WHERE cod_producto = NEW.cod_producto;
p = new.entrada + new.stock;
NEW.stock := p;
RETURN NEW;
END $actualizar_stock$ LANGUAGE plpgsql;
CREATE TRIGGER actualizar_stock BEFORE
INSERT
	OR
UPDATE ON distribuidora.producto FOR EACH ROW EXECUTE PROCEDURE distribuidora.stock();
CREATE FUNCTION distribuidora.subtotal_entrada() RETURNS TRIGGER AS $llenar_subtotal_entrada$
DECLARE p numeric;
d numeric;
su numeric;
vd numeric;
BEGIN -- Chequear cantidad null
IF NEW.cantidad_venta IS NULL THEN RAISE EXCEPTION '% Cantidad no puede ser nulo',
NEW.cod_producto;
END IF;
SELECT valor into p
FROM distribuidora.producto
WHERE cod_producto = NEW.cod_producto;
d := NEW.descuento / 100;
su := NEW.cantidad_venta * p;
vd := round((su * d), 2);
NEW.precio_venta := p;
NEW.subtotal := (su - vd);
NEW.vlr_descuento := vd;
RETURN NEW;
END $llenar_subtotal_entrada$ LANGUAGE plpgsql;
CREATE TRIGGER llenar_subtotal_entrada BEFORE
INSERT
	OR
UPDATE ON distribuidora.detalle_entrada FOR EACH ROW EXECUTE PROCEDURE distribuidora.subtotal_entrada();
CREATE FUNCTION distribuidora.total_entrada() RETURNS trigger AS $llenar_total_entrada$
declare sb numeric;
de numeric;
BEGIN
select sum(subtotal),
	sum(vlr_descuento) into sb,
	de
from distribuidora.detalle_entrada
where consecutivo_entrada = NEW.consecutivo_entrada;
update distribuidora.factura_entrada
set total = sb,
	descuento = de
where consecutivo_entrada = NEW.consecutivo_entrada;
RETURN NEW;
END;
$llenar_total_entrada$ LANGUAGE plpgsql;
CREATE TRIGGER llenar_total_entrada
AFTER
INSERT
	OR
UPDATE ON distribuidora.detalle_entrada FOR EACH ROW EXECUTE PROCEDURE distribuidora.total_entrada();


CREATE TABLE distribuidora.acceso (
	ACCE_USUARIO VARCHAR (35) NOT NULL,
	EMP_DOCUMENTO VARCHAR (15) NOT NULL,
	ACCE_CONTRASENA VARCHAR (45) NOT NULL,
	CONSTRAINT PK_ACCESO PRIMARY KEY (ACCE_USUARIO, EMP_DOCUMENTO),
	CONSTRAINT FK_EMPLEADO_ACCESO FOREIGN KEY(EMP_DOCUMENTO) REFERENCES distribuidora.empleado(EMP_DOCUMENTO)
);
	INSERT INTO distribuidora.acceso 	(ACCE_USUARIO,EMP_DOCUMENTO,ACCE_CONTRASENA)
								VALUES	('felipe42','1003125673','felipe123');

CREATE TABLE distribuidora.SUMINISTRA(
	sumi_id VARCHAR (10),
	fecha DATE,
	cod_producto VARCHAR (5),
	nit VARCHAR (20),
	CONSTRAINT PK_SUMINISTRA PRIMARY KEY (SUMI_ID, COD_PRODUCTO, NIT),
	CONSTRAINT CK_FECHA check (FECHA IS NOT NULL),
	CONSTRAINT FK_PRODUCTO_SUMINITRA FOREIGN KEY(COD_PRODUCTO) REFERENCES distribuidora.producto,
	CONSTRAINT FK_PROVEEDOR_SUMINISTRA FOREIGN KEY(NIT) REFERENCES distribuidora.proveedor
);